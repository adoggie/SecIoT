//
// Created by scott on 2020-08-14.
//

#include "DirectionIn.h"

#include "app.h"
#include "Connector.h"
#include "sdf-utils.h"
#include "GM50/gm0006.h"

ChannelDirectionIn::ChannelDirectionIn(bool secure,Connection::Ptr& conn,
        const std::shared_ptr<Connector>& connector ):ChannelDirection(secure,connector){

    conn_ = conn;
    conn_->setListener(this);
    connected_ = true;
}


void ChannelDirectionIn::onData(const char * data ,size_t size,const Connection::Ptr& conn){
    ChannelDirection::onData(data,size,conn);
}

bool ChannelDirectionIn::init(const Config& props){
    cfgs_ = props;


//    std::string value = cfgs_.get_string("local_pri_key");
//    std::copy( value.begin(),value.begin()+value.size(),std::back_inserter(settings_.local_pri_key));
//
//    settings_.local_id.resize(32);
//    value = cfgs_.get_string("local_id");
//    std::copy_n( value.begin(),value.size(),settings_.local_id.begin());

    return true;
}

bool ChannelDirectionIn::open(){
    onConnected(conn_);
    return true;
}

void ChannelDirectionIn::close(){
    SecChannel::close();
}

void ChannelDirectionIn::onConnected(const Connection::Ptr& conn){
    auto next = connector_->createNextHop();
}

void ChannelDirectionIn::onDisconnected(const Connection::Ptr& conn){
//    std::lock_guard<std::recursive_mutex> lock(this->rmutex_);
    Application::instance()->getLogger().debug("ChannelDirectionIn::Connection Disconnected..");
    resetStatus();
    auto peer = this->against();
    if(peer) {
        peer->close();
    }
    connector_->onLostChannel(shared_from_this());

}

// 0: not reachable , 1: timeout
void ChannelDirectionIn::onConnectError(const Connection::Ptr& conn,ConnectionError error){
//    std::lock_guard<std::recursive_mutex> lock(this->rmutex_);
    resetStatus();
}


void ChannelDirectionIn::resetStatus(){
    SecChannel::resetStatus();

}

void ChannelDirectionIn::onMessageChannelCreateRequest(const MessageChannelCreateRequest::Ptr& message){
//    std::lock_guard<std::recursive_mutex> lock(this->rmutex_);
    settings_.remote_id = message->envelope->source; // 远端客户设备编号 32 bytes
    // to match remote's pub-key
    // 根据连接设备编号找到对点设备的公钥

    settings_.remote_pub_key= this->getRemotePubkey(settings_.remote_id);

    // 使用本地私钥解出 临时共享密钥

    sdf::data_dec(sdf::KeyID(0),SGD_SM2,settings_.local_pri_key.data(),settings_.local_pri_key.size(),
                  message->enc_data.data(),message->enc_data.size(), settings_.temp_peer_key);

    ////////  response to peer
    sdf::random_create(settings_.temp_key,32);

    auto response = std::make_shared<MessageChannelCreateResponse>();
    {
        ByteArray data; //= settings_.temp_peer_key+ settings_.temp_key;
        std::copy(settings_.temp_peer_key.begin(), settings_.temp_peer_key.end(), std::back_inserter(data));
        std::copy(settings_.temp_key.begin(), settings_.temp_key.end(), std::back_inserter(data));
        sdf::data_enc(sdf::KeyID(0),SGD_SM4_ECB,settings_.remote_pub_key.data(), settings_.remote_pub_key.size(),
                      data.data(), data.size(),response->enc_data);
    }
    {
        sdf::data_sign(sdf::KeyID(0),SGD_SM2,settings_.local_pri_key.data(),settings_.local_pri_key.size(),
                       settings_.temp_key.data(),settings_.temp_key.size(),
                       response->sign_data
        );
    }

    auto evp = this->prepareEnvelope(response);
    sendEnvelope(evp);

    channel_okay_ = true;
}

void ChannelDirectionIn::onMessageChannelCreateResponse(const MessageChannelCreateResponse::Ptr& message){
    SecChannel::onMessageChannelCreateResponse(message);
}

void ChannelDirectionIn::onMessageChannelSend(const MessageChannelSend::Ptr& message){
    SecChannel::onMessageChannelSend(message);

//    SecChannel::onMessageChannelSend(message);
//    if( message->detail->app_id == AppID::UserAppExt ){
//        auto m = std::dynamic_pointer_cast<CommandUserAppJsonMessage>(message->detail);
//        if( !upstream_){
//            upstream_ = std::make_shared<UpstreamService>();
//            upstream_->init( this->shared_from_this(), cfgs_);
//            if( !upstream_->open() ){
//                std::cout<< "Upstream Open Failed!"<< std::endl;
//                this->close();
//            }
//        }
//        upstream_->redirectData( m->data );
//        std::cout << "redirect data:" << m->data.size() << std::endl ;
//        std::for_each(m->data.begin(),m->data.end(),[](int v){
//            std::cout<< "0x"<< std::hex<< v << "," ;
//        });
//        std::cout<< std::endl;
//
//    }
}

void ChannelDirectionIn::onMessageChannelReCreateRequest(const MessageChannelReCreateRequest::Ptr& message){

}


