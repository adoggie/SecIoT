//
// Created by scott on 2020-08-14.
//

#include "Connector.h"
#include "app.h"
#include "DirectionIn.h"
#include "DirectionOut.h"
#include "Controller.h"


bool Connector::init(const Config& cfgs){
    id_ = std::time(NULL);

    boot_time_ = std::time(NULL);
    settings_.login_inited = false;

    cfgs_ = cfgs;
    auto address = cfgs.get_string("listen_ip","127.0.0.1");
    auto port = cfgs.get_int("listen_port",9900);
    settings_.in_secure = cfgs.get_string("in_secure") =="true"?true:false;
    settings_.out_secure = cfgs.get_string("out_secure") =="true"?true:false;


//    server_ = std::make_shared<SocketServer>( this->get_io_service(),address,(unsigned short)port);
//    server_->setListener(this);
//
//    check_timer_interval_ = 5;
//    timer_ = std::make_shared<boost::asio::steady_timer>(Application::instance()->getConnector()->get_io_service());
//    timer_->expires_after(std::chrono::seconds( check_timer_interval_));
//    timer_->async_wait(std::bind(&Connector::workTimedTask, this));

    return true;
}

bool Connector::open(){
//    server_->start();
    return true;
}


void Connector::close(){

}

void Connector::run(){
//    get_io_service().run();
}

void Connector::incoming(const Connection::Ptr& conn){
    Application::instance()->getLogger().debug("New  Connection Established!");
//    in_ = std::make_shared<ChannelDirectionIn>(settings_.in_secure,conn,shared_from_this());
    in_->init(cfgs_);
    in_->open();
}

void Connector::onConnected(const Connection::Ptr& conn){
    Application::instance()->getLogger().debug("New  Connection Established!");
//    auto channel = std::make_shared<ServerSideSecChannel>();
//
//    channel->init(cfgs_);
//    channel->onConnected(conn);
//    channels_[conn->id()] = channel;
//    conn->setListener(channel.get());
}

//外部连接丢失
void Connector::onDisconnected(const Connection::Ptr& conn){

}

void Connector::onData(const char * data ,size_t size,const Connection::Ptr& conn){
//    std::lock_guard<std::recursive_mutex> lock(this->rmutex_);
//    auto channel = channels_[conn->id()];
//    channel->onData(data,size,conn);
}

void Connector::onConnectError(const Connection::Ptr& conn,ConnectionError error){
}


void Connector::onLostChannel(const SecChannel::Ptr peer){
    ChannelDirection::Ptr  other;
    if( in_ == peer){
        other = out_;
    }else{
        other = in_;
    }
    if(other){
        other->close();
    }
    Controller::instance()->onConnectorClosed(shared_from_this());
}

ChannelDirection::Ptr Connector::createNextHop(){
    out_ = std::make_shared<ChannelDirectionOut>( settings_.out_secure,shared_from_this());
    out_->open();
    return out_;
}

ChannelDirection::Ptr Connector::against(const SecChannel::Ptr& channel){
    if( in_ == channel){
        return out_;
    }
    return in_;
}

std::uint64_t   Connector::id(){
    return std::time(NULL);
}